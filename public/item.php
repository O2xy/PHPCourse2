<?php
class Item {
    public $id;
    public $name;
    public $description;
    public $price;
    public $count;
    public $discount; // храним в виде десятичной дроби от 0 до 1

    public function __construct($id, $name, $description, $price, $count, $discount = 0)
    {
        $this->id = $id;
        $this->name = $name;
        $this->description = $description;
        $this->price = $price;
        $this->count = $count;
        $this->discount = $discount;
    }

    protected function countPrice() {
        if (($this->discount > 0) && ($this->discount <= 1)) {
            return (($this->price) * (1 - $this->discount));
        } else {
            return $this->price;
        }
    }

    public function display() { //Сделал, чтоб самому видеть процесс работы
        echo "<h1>{$this->name}</h1>";
        echo "<p>{$this->description}</p>";
        echo "<p>Осталось: {$this->count}</p>";
        echo "<p>Цена: {$this->countPrice()}</p>";
    }

    public function changeCount(int $num){
        if (($num > 0) || ($this->count >= abs($num))){
            $this->count += $num;
        } else {
            echo 'alert("Вы пытаетесь вычесть товара больше, чем его есть.")';
        }
    }

}

class ItemWithUnit extends Item { //допустим, появислся товар, который продаётся наразвес, будем указывать единицы измерения
    public $unit;
    public function __construct($id, $name, $description, $price, $count, $unit, $discount = 0){
        parent::__construct($id, $name, $description, $price, $count, $discount);
        $this->unit = $unit;
    }

}

$firstItem = new Item(1, 'параллелограмм', 'Др.-греч. παραλληλόγραμμον от παράλληλος — параллельный и γραμμή — линия. Это четырёхугольник, у которого противоположные стороны попарно параллельны, то есть лежат на параллельных прямых. Частными случаями параллелограмма являются прямоугольник, квадрат и ромб.', 500, 25);
$firstItem->display();
$firstItem->changeCount(-50);
$firstItem->changeCount(50);
$firstItem->changeCount(-60);
$firstItem->display();

$secondItem = new Item(2, 'окружность', 'Замкнутая плоская кривая, которая состоит из всех точек на плоскости, равноудалённых от заданной точки: эта точка называется центром окружности. Отрезок, соединяющий центр с какой-либо точкой окружности, называется радиусом; радиусом называется также и длина этого отрезка. Окружность разбивает плоскость на две части — конечную внутреннюю и бесконечную внешнюю. Внутренность окружности называется кругом; граничные точки (то есть саму окружность) в зависимости от подхода, круг может включать или не включать.', 300, 64, 0.3);
$secondItem->display();




//class A {                     //объявляем новый класс
//    public function foo() {   //объявляем публичный метод класса
//        static $x = 0;        //Задаём статичную переменную, которая хранится в классе, а не в объекте
//        echo ++$x;            //выводим переменную, предварительно увеличив её на единицу
//    }
//}
//$a1 = new A();                //создаём первый экземпляр класса
//$a2 = new A();                //создаём второй экземпляр класса
//$a1->foo();                   //вызываем функцию объекта, которая изменяет переменную в классе, выводим её
//$a2->foo();                   //вызываем функцию объекта, которая изменяет переменную в классе, выводим её
//$a1->foo();                   //вызываем функцию объекта, которая изменяет переменную в классе, выводим её
//$a2->foo();                   //вызываем функцию объекта, которая изменяет переменную в классе, выводим её
                                // переменная увеличивается каждый раз, т.к. она хранится в классе, разные объекты обращаются к одной переменной

//class A {                     //объявляем новый класс
//    public function foo() {   //объявляем публичный метод класса
//        static $x = 0;        //Задаём статичную переменную, которая хранится в классе, а не в объекте
//        echo ++$x;            //выводим переменную, предварительно увеличив её на единицу
//    }
//}
//class B extends A {           //создаём новый класс - наследник
//}
//$a1 = new A();                //создаём экземпляр первого класса
//$b1 = new B();                //создаём экземпляр второго класса
//$a1->foo();                   //вызываем функцию объекта, которая изменяет переменную в первом классе, выводим её
//$b1->foo();                   //вызываем функцию объекта, которая изменяет переменную во втором классе, выводим её
//$a1->foo();                   //вызываем функцию объекта, которая изменяет переменную в первом классе, выводим её
//$b1->foo();                   //вызываем функцию объекта, которая изменяет переменную во втором классе, выводим её
                                // отличие от первого случая в том, что имеются два объекта двух классов, хоть один из класов и является наследником другого
